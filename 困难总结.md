前几天发生的一个例子，
BA有一个bug提出来，大致功能是需要返回前一页的时候前一页还带着原来的数据没有刷新，目前是回到前一页会自动刷新的。
因为我对vue这一块不太熟悉，我想到的先是确认任务需求，应该是要跳转前缓存当前页面，下一次进入该页面时直接用缓存。然后从代码里确认跳转的起点和终点，大概熟悉一下跳转的过程。评估了任务的复杂度之后，我问BA这个是之前实现过的功能吗？因为从0实现需要的effort远大于模仿现有的逻辑，这一步也是先预计需要花的时间。BA给我展示了对应的能缓存的页面之后我又去另一个对应的页面代码，看他们的缓存和跳转逻辑处理。但是问题来了，我发现两者几乎完全一样。没办法，我只能先打印出对应的生命周期，先看它们是不是按照标准的生命周期实现缓存，也就是是否通过keep-alive。在这里我发现了区别，正常走缓存的页面确实只走了一次created生命周期，但异常页面每次进入都会重走一遍created。为什么会造成这样的区别呢？我先看它们跳转的逻辑，将它们跳转的逻辑做到了完全一致之后再试，还是有异常，那就奇怪了，难道是缓存机制不同，我就去研究它们的公共方法，这里面又设计到vue-router和vuex的东西，并且因为是微前端，又不在同一个库里面，只能一点一点做好埋点并打印信息可是直到最后打印的信息都是完全相同的逻辑，没有不同。此时我开始深入理解keep-alive并在网上搜相关的文章，试了将近半天的时间后我告诉前端组长这个可能有点棘手需要帮助，他也是恰好主用vue的前端，可惜他也在忙，后来我就先搁置这个bug改其他东西去了。一是可能有惯性思维，下一次再想的时候能从其他角度开始突破，二是这个花的effort已经到了原先预计的effort了，不能死扛这一个而耽误了其他的进度。三是提醒组长重新评估bug难度安排effort。
第二天，我在提前做完了其他task的情况下空余出一些时间，便又开始询问组长安排的情况以及自己重新看对应的文档，终于在各种尝试之后明白了keep-alive对应的name是组件的name而不是route的name，但我们保存时都是保存的route的name到vuex里，之后再拿出来进行keep-alive的includes的正则匹配，只要它们的routeName和componentName保持一致就没问题，但这次不一致导致了问题。修改后手动切换页面时能有缓存了，之前埋点的生命周期也都正常了。但是通过route跳转的方式还是会刷新页面不走缓存，我又查看跳转的公共方法以及比对vuex里的数据发现跳转的方法也有问题，重复删除了缓存。为此又得查看公共方法的细节实现，改了之后又评估测试了一下其他页面，最终正常之后提交了bug修复，以及提醒组长和其他前端同事注意类似的情况和公共方法，并把这次的修bug总结出经验加到笔记里